---
layout: post
title: SOLID 객체지향 설계원칙
description: >
  좋은 객체 지향 설계의 5원칙, SOLID에 대한 정리
categories: computer
---
# SOLID
로버트 마틴이 정리한 객체 지향 프로그래밍의 설계 기본 원칙 5가지의 앞글자를 딴 것.

[5가지 원칙]
- SRP(Single responsibility principle), 단일 책임 원칙
- OCP(Open/Closed principle), 개방-폐쇄 원칙
- LSP(Liskov substitution principle), 리스코프 치환 원칙
- ISP(Interface segregation principle), 인터페이스 분리 원칙
- DIP(Dependency Inversion Principle), 의존 관계 역전 원칙

---

## SRP, 단일 책임의 원칙
하나의 클래스는 하나의 목적(책임)만 가져야 한다. 하나의 책임은 클 수도 작을 수도 있고 문맥과 상황에 따라 다르다.  
클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어 있어야 한다.  
5원칙 중 나머지 4원칙의 기초가 되는 원칙이다.

| 클래스를 변경하는 이유는 단 한 가지여야 한다.

단일 책임이 잘 지켜졌는지를 판단할 때 변경을 기준으로 하는데,   
변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른 것이라고 할 수 있다.

<br>
<br>

## OCP, 개방 폐쇠의 원칙
소프트웨어의 구성요소인 컴포넌트, 클래스, 모듈, 함수 등은 확장에는 열려있으나 변경에는 닫혀있어야한다.
더 정확히 말하면 사용되는 기능의 확장에는 열려있고 그 기능을 사용하는 코드의 변경에는 닫혀있어야한다.  
 
이 원칙은 다형성과 확장 등 객체지향의 장점을 극대화하는 설계 원칙이며, 역할과 구현을 분리함으로써 구현이 가능하다.
<br>
<br>


## LSP, 리스코프 치환 원칙
서브타입(하위 클래스)는 어디서나 자신의 기반 타입(상위 클래스)으로 교체할 수 있어야 한다는 원칙.
다형성에서 하위클래스는 인터페이스 규약을 모두 준수해야한다는 것을 의미하며, 인터페이스를 구현한 구현체를 신뢰하고 사용하기 위해서는 이 원칙을 지켜야한다.

예시로 자동차 인터페이스를 설계했고 앞으로 가게하는 엑셀을 메소드로 가진다했을때, 자동차 인터페이스를 구현한 소나타 클래스가 엑셀 메소드에서 앞으로 가지않고 뒤로 가는 기능을 가진다면 이 구현체를 신뢰하고 사용하기 어렵다.
컴파일은 성공하겠지만 좋은 코드는 아니다.

<br>
<br>

## ISP, 인터페이스 분리의 원칙
하나의 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙이다.  
설계 시 특정 기능에 대한 인터페이스는 그 기능과 상관없는 부분이 변해도 영향을 받지 않아야 한다.  

정의로는 의미가 와닿지 않는다.  
특정 클라이언트를 위해 세부적으로 여러 인터페이스를 만드는 것이 범용 인터페이스 하나보다 낫다는 것을 의미하는데,
만약 자동차의 사용자 클라이언트 인터페이스를 설계할 때, 사용자 인터페이스 하나로 설계하는 것보다   
사용자에는 운전자, 정비사 등이 있을 수 있으므로 운전자 인터페이스, 정비사 인터페이스로 따로 설계하는 것이 좋다.  
이렇게 설계하게 되면 운전자 인터페이스에 변경이 있을때, 정비사 인터페이슨는 영향을 받지 않기 때문이다.  


이 원칙을 통해 인터페이스가 명확해지고 대체가능성을 높일 수 있다.

<br>
<br>

## DIP, 의존관계 역전 원칙
실제 사용 관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고받음으로써 관계를 최대한 느슨하게 만드는 원칙이다.
구현클래스가 아닌 인터페이스에 의존하라는 의미이다.
<br>

| 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다."

<br>
<br>

---

<br>
<br>

자바로 객체지향개발을 할 때, 순수 다형성만으로는 OCP원칙과 DIP원칙을 지키기 어렵다.
따라서 스프링에서는 DI, Dependency Injection을 통해서 위의 두 원칙을 지키게 해준다.

예시로 Repository 인터페이스의 구현체인 MemoryRepository가 있고,
Service 클라이언트에서 MemoryRepository를 사용할 때 코드는 다음과 같다.

```java
public Service {
    Repository repo = new MemoryRepository();
}
```

그런데 Repository 구현체를 MemoryRepository가 아닌 DBRepository로 변경하고 싶다면 어떻게 해야할까?
Service 클라이언트 코드의 수정이 필요하다.

```java
public Service {
    Repository repo = new DBRepository();
}
```

다형성을 활용하여 설계를 했지만, 클라이언트 코드 변경이 필요하여 OCP 원칙이 위반되었다.
스프링은 DI를 통해 이를 해결한다.
스프링 컨테이너(스프링 빈)에 Repository 구현체가 등록되고,   
Service 인스턴스를 생성할 때, 컨테이너에 등록된 Repository 구현체를 **주입** 해준다.  


```java
public Service {
    private final Repository memberRepository;

    public Service(Repository memberRepository) {
        this.memberRepository = memberRepository;
    }
}
```

이를 IoC(Inversion of Control), 제어의 역전이라고도 한다.
서비스 코드를 실행하는 코드에서는 어떠한 구현체가 실행되는지 모르고, 프로그램의 실행흐름을 다른 위치에서 가져가기 때문이다.







